package embedding

import (
	"context"
	"hash/fnv"
)

const mockEmbeddingDim = 1536 // Same dimension as text-embedding-3-small

// MockClient returns deterministic embeddings for testing.
// Embeddings are generated by hashing the input text.
type MockClient struct {
	// EmbedResponse allows overriding the default hash-based embedding
	EmbedResponse []float32
	EmbedError    error

	// Call tracking for assertions
	EmbedCalls []string
}

func NewMockClient() *MockClient {
	return &MockClient{}
}

func (c *MockClient) Embed(ctx context.Context, text string) ([]float32, error) {
	c.EmbedCalls = append(c.EmbedCalls, text)
	if c.EmbedError != nil {
		return nil, c.EmbedError
	}
	if c.EmbedResponse != nil {
		return c.EmbedResponse, nil
	}
	return generateDeterministicEmbedding(text), nil
}

// generateDeterministicEmbedding creates a reproducible embedding based on text hash.
// This ensures the same text always produces the same embedding for consistent tests.
func generateDeterministicEmbedding(text string) []float32 {
	h := fnv.New64a()
	h.Write([]byte(text))
	seed := h.Sum64()

	embedding := make([]float32, mockEmbeddingDim)
	for i := range embedding {
		// Use simple LCG for deterministic pseudo-random values
		seed = seed*6364136223846793005 + 1442695040888963407
		// Normalize to [-1, 1] range
		embedding[i] = float32(int64(seed>>33)-int64(1<<30)) / float32(1<<30)
	}

	// Normalize the vector to unit length
	var norm float32
	for _, v := range embedding {
		norm += v * v
	}
	norm = sqrt32(norm)
	if norm > 0 {
		for i := range embedding {
			embedding[i] /= norm
		}
	}

	return embedding
}

func sqrt32(x float32) float32 {
	if x <= 0 {
		return 0
	}
	// Newton's method for square root
	z := x / 2
	for i := 0; i < 10; i++ {
		z = (z + x/z) / 2
	}
	return z
}

// Reset clears recorded calls and responses.
func (c *MockClient) Reset() {
	c.EmbedResponse = nil
	c.EmbedError = nil
	c.EmbedCalls = nil
}
